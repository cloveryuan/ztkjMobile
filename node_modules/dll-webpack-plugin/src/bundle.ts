import * as webpack from "webpack";
import * as path from "path";
import Util from "./util";
import {
    MANIFEST_JSON_PATH,
    DLL_PATH,
    PLUGIN_PATH,
    DLL_VERSION_JSON_PATH,
    defaultDllVersionJson,
    NODE_ENV,
    DEFAULT_PACKAGE_JSON_PATH,
    DEFAULT_LIBRARY
} from "./constant";

export interface BundleOptions {
    dllConfig: webpack.Configuration;
}

export default class Bundle {
    constructor(options: BundleOptions) {
        this.options = options;
        this.initDllConfig();
    }
    private readonly options: BundleOptions;
    private dllConfig: webpack.Configuration;
    private chunkFiles: string[];

    private initDllConfig(): void {
        const { dllConfig  } = this.options;
        const dllPlugin = new webpack.DllPlugin({
            path: MANIFEST_JSON_PATH,
            name: DEFAULT_LIBRARY,
        });
        const output = {
            ...dllConfig.output,
            path: DLL_PATH,
            library: DEFAULT_LIBRARY
        };
        const plugins = dllConfig.plugins ? dllConfig.plugins
                .filter(plugin => !(plugin instanceof webpack.DllPlugin))
                .concat([dllPlugin]) : [dllPlugin]
        this.dllConfig = {
            ...dllConfig,
            output,
            plugins
        };
    }
    private shouldRegenerateHash(): boolean {
        const { dllConfig  } = this.options;
        const filename = dllConfig.output!.filename;
        return /\[\S*hash\S*\]/.test(filename as string);
    }
    private regenerateHash() {
        const fileMd5Hash = Util.getFileVersion(JSON.stringify(this.dllConfig, Util.replacerPath) + JSON.stringify(this.getCurrentDllEntry()));
        this.getAbsoluteAssetsPath()
            .forEach((oldPath, index) => {
                const oldChunkFile = this.chunkFiles[index];
                const newChunkFile = oldChunkFile.split('.').map((chunk, chunkIndex) => {
                    if (chunkIndex === oldChunkFile.split('.').length - 2) {
                        return fileMd5Hash.slice(0, 8)
                    }
                    return chunk
                }).join('.');
                const newPath = oldPath.replace(oldChunkFile, newChunkFile)
                this.chunkFiles[index] = newChunkFile;
                Util.renameSync(oldPath, newPath);
            })
    }
    public getRelativeAssetsPath(from: string): string[] {
        return this.chunkFiles.map(file =>
            path.normalize(`${path.relative(from, (this.options.dllConfig as any).output.path)}/${file}`)
        );
    }
    public getAbsoluteAssetsPath(): string[] {
        return this.chunkFiles.map(file =>
            path.normalize(`${(this.dllConfig as any).output.path}/${file}`)
        );
    }
    public getCurrentDllEntry(): {[name: string]: any } {
        const packageJson = Util.readJson(DEFAULT_PACKAGE_JSON_PATH);
        const entry = this.dllConfig.entry as webpack.Entry;
        return Object.keys(entry).reduce((preVal, currentVal) => {
                preVal[currentVal] = Array.isArray(entry[currentVal]) ?
                    (entry[currentVal] as string[]).reduce((pVal, cVal) => {
                        pVal[cVal] = packageJson.dependencies[cVal] || 0;
                        return pVal;
                    }, {})
                    :
                    packageJson.dependencies[currentVal] || 0;
                return preVal;
            }, {});
    }
    public shouldRepackaged(): boolean {
        const isFirstUsePlugin = !Util.fileExist(PLUGIN_PATH);
        const isFirstUseCurrentEnv = !Util.fileExist(DLL_PATH);
        const currentDllConfig = Util.getFileVersion(JSON.stringify(this.dllConfig));
        const currentDllEntry = Util.getFileVersion(JSON.stringify(this.getCurrentDllEntry()));
        
        if (isFirstUsePlugin) {
            const dllVersionJson = {...defaultDllVersionJson};
            dllVersionJson.dllConfig[NODE_ENV] = currentDllConfig;
            dllVersionJson.dllEntry = currentDllEntry;
            Util.writeJson(DLL_VERSION_JSON_PATH, dllVersionJson);
            return true;
        }

        let dllVersionJson;
        if (Util.fileExist(DLL_VERSION_JSON_PATH)) {
            dllVersionJson = Util.readJson(DLL_VERSION_JSON_PATH);
        } else {
            dllVersionJson = {...defaultDllVersionJson};
            Util.writeJson(DLL_VERSION_JSON_PATH, dllVersionJson);
        }

        if (dllVersionJson.alwayForceUpdate) {
            Util.removeFile(DLL_PATH);
            return true;
        }

        if (dllVersionJson.onceForceUpdate) {
            Util.removeFile(DLL_PATH);
            dllVersionJson.onceForceUpdate = false;
            Util.writeJson(DLL_VERSION_JSON_PATH, dllVersionJson);
            return true;
        }

        if (isFirstUseCurrentEnv) {
            return true;
        }

        if (currentDllConfig !== dllVersionJson.dllConfig[NODE_ENV]) {
            Util.removeFile(DLL_PATH);
            dllVersionJson.dllConfig[NODE_ENV] = currentDllConfig;
            Util.writeJson(DLL_VERSION_JSON_PATH, dllVersionJson);
            return true;
        }

        if (currentDllEntry !== dllVersionJson.dllEntry) {
            Util.removeFile(DLL_PATH);
            dllVersionJson.dllEntry = currentDllEntry;
            Util.writeJson(DLL_VERSION_JSON_PATH, dllVersionJson);
            return true;
        }

        this.chunkFiles = Util.readDir(DLL_PATH).filter(file => file.substr(file.length -2) === "js");

        return  false;
    }
    public repackaged(): Promise<string[]> {
        Util.warn("dll-webpack-plugin: re building !");
        return new Promise<string[]>((res, rej) => {
            webpack(this.dllConfig, (err: Error, stats: webpack.Stats) => {
                if (err) {
                    Util.error("dll-webpack-plugin: " + err.message);
                    return rej(err);
                }
                Util.success("dll-webpack-plugin: build success !");
                const chunks = stats.toJson().chunks
                this.chunkFiles = chunks.reduce((preVal, currentVal) => {
                    return currentVal.files.reduce((pVal, cVal) => {
                        return pVal.concat(cVal);
                    }, preVal)
                }, []);
                if (this.shouldRegenerateHash()) {
                    this.regenerateHash();
                }
               return res(this.chunkFiles);
            });
        })
    }
}