import * as webpack from "webpack";
import * as path from "path";
import Bundle, {
    BundleOptions
} from "./bundle";
import Util from "./util";
import {
    PLUGIN_PATH,
    NODE_ENV,
    PLUGIN_NAME
} from "./constant";

enum HookMethod {
    TAP = "tap",
    TAP_ASYNC = "tapAsync",
    TAP_PROMISE = "tapPromise",
    INTERCEPT = "intercept"
}

interface DllWebpackPluginOptions extends webpack.DllReferencePlugin.Options, BundleOptions {
}

class DllWebpackPlugin implements webpack.Plugin {
    constructor(options) {
        this.options = options;
        this.bundle = new Bundle({
            dllConfig: options.dllConfig,
        });
        this.apply = this.apply.bind(this);
        this.addFileToAssets = this.addFileToAssets.bind(this);
        this.injectAssetsIntoHtml = this.injectAssetsIntoHtml.bind(this);
        this.compatibilityHooks = this.compatibilityHooks.bind(this);
    }
    private readonly options: DllWebpackPluginOptions;
    private readonly bundle: Bundle;
    private isFirstCompile: boolean = true;

    public apply(compiler: webpack.Compiler): void {
        const hookFuc = async (params, callback) => {
            if (this.isFirstCompile) {
                this.isFirstCompile = false;
                this.bundle.shouldRepackaged() && await this.bundle.repackaged();
                this.addFileToAssets(compiler);
                this.injectAssetsIntoHtml(compiler);
                this.applyDllReferencePlugin(compiler);
                callback();
            }
            else {
                callback();
            }
        }
        this.compatibilityHooks(compiler, "before-compile", hookFuc, HookMethod.TAP_ASYNC);
    }
    private applyDllReferencePlugin(compiler: webpack.Compiler): void {
        const dllReferencePluginOptions: webpack.DllReferencePlugin = {...this.options} as any;
        Reflect.deleteProperty(dllReferencePluginOptions, "dllConfig");
        Reflect.ownKeys(this.options.dllConfig.entry as webpack.Entry)
            .forEach(entry => {
                const dllReferencePlugin = new webpack.DllReferencePlugin({
                    ...dllReferencePluginOptions,
                    context: ".",
                    manifest: require(`${PLUGIN_PATH}/${NODE_ENV}/${entry}.manifest.json`),
                });
                compiler.apply(dllReferencePlugin);
            })
    }
    private addFileToAssets(compiler: webpack.Compiler): void {
        const hookFuc = (compilation, callback) => {
            const templatePath = path.normalize((compiler.options.output as any).path);
            const absolutePath = this.bundle.getAbsoluteAssetsPath();
            const relativePath = this.bundle.getRelativeAssetsPath(templatePath);
            relativePath.forEach((asset, index) => {
                const fileSource = Util.readFile(absolutePath[index]);
                compilation.assets[asset] = {
                    source() {
                      return fileSource;
                    },
                    size() {
                      return fileSource.length;
                    }
                };
            });
            callback();
        }
        this.compatibilityHooks(compiler, "emit", hookFuc, HookMethod.TAP_ASYNC);
    }
    private injectAssetsIntoHtml(compiler: webpack.Compiler): void {
        const publicPath = (compiler.options.output as any).publicPath;
        const hookCompilation = compilation => {
            const hookFuc = (result, callback) => {
                const templatePath = path.normalize((compiler.options.output as any).path);
                result.assets.js = this.bundle.getRelativeAssetsPath(templatePath)
                    .map(filePath => publicPath ? Util.pathJoin(publicPath, filePath) : filePath)
                    .concat(result.assets.js);
                callback(null, result);
            }
            this.compatibilityHooks(compilation, "html-webpack-plugin-before-html-generation", hookFuc, HookMethod.TAP_ASYNC);
        };
        this.compatibilityHooks(compiler, "compilation", hookCompilation, HookMethod.TAP);
    }
    private compatibilityHooks(compiler, eventName: string, hookFuc: Function, hookMethod: HookMethod): boolean {
        if (Reflect.has(compiler, "hooks")) {
            const ccEventName = Util.trainCaseToCamelCase(eventName);
            if (!compiler.hooks[ccEventName]) {
                throw new Error('No hook found for ' + eventName);
            }
            compiler.hooks[ccEventName][hookMethod](PLUGIN_NAME, hookFuc);
            return true;
        } else {
            compiler.plugin(eventName, hookFuc);
            return true;
        }
    }
}

module.exports = DllWebpackPlugin;